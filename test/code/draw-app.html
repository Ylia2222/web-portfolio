<!--
Функции:
    -Холст для рисования;
    -Размер, цвет кисти;
    -Заливка;
    -Отчистка холста;
    -Сохранение рисунка;
    
Новые функции:
    -Заливка как отдельный инструмент;
    -Заливка замкнутых фигур;
    -Ластик как инструмент;    
-->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Расширенное приложение для рисования</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }

        canvas {
            border: 1px solid black;
            cursor: crosshair;
        }

        .controls {
            margin: 10px 0;
        }

        label {
            margin-right: 10px;
        }

        button {
            margin: 0 5px;
        }
    </style>
</head>

<body>

    <h2>Приложение для рисования</h2>

    <div class="controls">
        <label>Цвет кисти/заливки: <input type="color" id="colorPicker" value="#000000"></label>
        <label>Размер кисти/ластика: <input type="range" id="brushSize" min="1" max="30" value="5"></label>
        <button id="penBtn" class="toolBtn active">Кисть</button>
        <button id="fillBtn" class="toolBtn">Заливка</button>
        <button id="eraserBtn" class="toolBtn">Ластик</button>
        <button id="clearBtn">Очистить холст</button>
    </div>

    <canvas id="canvas" width="800" height="500"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');

        const penBtn = document.getElementById('penBtn');
        const fillBtn = document.getElementById('fillBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const clearBtn = document.getElementById('clearBtn');
        const toolButtons = document.querySelectorAll('.toolBtn');

        let currentTool = 'pen'; // pen, fill, eraser
        let isDrawing = false;

        function setActiveTool(tool) {
            currentTool = tool;
            toolButtons.forEach(btn => btn.classList.remove('active'));
            if (tool === 'pen') penBtn.classList.add('active');
            else if (tool === 'fill') fillBtn.classList.add('active');
            else if (tool === 'eraser') eraserBtn.classList.add('active');
        }

        penBtn.onclick = () => setActiveTool('pen');
        fillBtn.onclick = () => setActiveTool('fill');
        eraserBtn.onclick = () => setActiveTool('eraser');
        clearBtn.onclick = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

        function startDrawing(e) {
            if (currentTool === 'fill') {
                floodFill(e.offsetX, e.offsetY, hexToRgb(colorPicker.value));
                return;
            }
            if (currentTool === 'pen' || currentTool === 'eraser') {
                isDrawing = true;
                ctx.beginPath();
                ctx.moveTo(e.offsetX, e.offsetY);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            if (currentTool === 'pen') {
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = '#FFFFFF'; // белый цвет для ластика
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
            }
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Преобразование HEX в RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return {
                r,
                g,
                b
            };
        }

        // Сравнение цвета с допуском
        function colorMatch(data, pos, color, tolerance = 32) {
            return (
                Math.abs(data[pos] - color.r) <= tolerance &&
                Math.abs(data[pos + 1] - color.g) <= tolerance &&
                Math.abs(data[pos + 2] - color.b) <= tolerance
            );
        }

        // Алгоритм заливки flood fill
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            const pixelPos = (startY * width + startX) * 4;
            const startColor = {
                r: data[pixelPos],
                g: data[pixelPos + 1],
                b: data[pixelPos + 2],
                a: data[pixelPos + 3]
            };

            function matchColor(pos) {
                return (
                    Math.abs(data[pos] - startColor.r) < 10 &&
                    Math.abs(data[pos + 1] - startColor.g) < 10 &&
                    Math.abs(data[pos + 2] - startColor.b) < 10 &&
                    data[pos + 3] === startColor.a
                );
            }

            if (
                fillColor.r === startColor.r &&
                fillColor.g === startColor.g &&
                fillColor.b === startColor.b
            ) {
                return; // цвет заливки совпадает с цветом начальной точки — не надо ничего делать
            }

            let stack = [
                [startX, startY]
            ];

            while (stack.length) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;

                const pos = (y * width + x) * 4;
                if (!matchColor(pos)) continue;

                data[pos] = fillColor.r;
                data[pos + 1] = fillColor.g;
                data[pos + 2] = fillColor.b;
                data[pos + 3] = 255;

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        setActiveTool('pen'); // по умолчанию кисть
    </script>

</body></html>